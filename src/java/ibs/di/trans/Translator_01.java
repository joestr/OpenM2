/*
 * Class: Translator_01.java
 */

// package:
package ibs.di.trans;

// imports:
//KR TODO: unsauber
import ibs.bo.Buttons;
import ibs.bo.Datatypes;
import ibs.bo.OID;
import ibs.di.DIArguments;
import ibs.di.DIConstants;
import ibs.di.DIMessages;
import ibs.di.DITokens;
import ibs.di.DataElement;
import ibs.di.Log_01;
import ibs.ml.MultilingualTextProvider;
import ibs.obj.doc.File_01;
import ibs.service.user.User;
import ibs.tech.html.TableElement;
import ibs.tech.sql.Parameter;
import ibs.tech.sql.ParameterConstants;
import ibs.tech.sql.StoredProcedure;
import ibs.tech.xslt.XSLTTransformationException;
import ibs.tech.xslt.XSLTTransformer;
import ibs.util.file.FileHelpers;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;


/******************************************************************************
 * The Translator_01 class handles all kinds of transformations. Each
 * subclass of translator only supports one translation. The translator
 * object will be used exclusively for XML transformations, but can be extended
 * to support other formats in the future. <BR/>
 *
 * @version     $Id: Translator_01.java,v 1.30 2013/01/16 16:14:11 btatzmann Exp $
 *
 * @author      Buchegger Bernd (BB), 991008
 ******************************************************************************
 */
public class Translator_01 extends File_01 implements TranslatorInterface
{
    /**
     * Version info of the actual class. <BR/>
     * This String contains the version number, date, and author of the last
     * check in to the code versioning system. This is implemented as CVS tag
     * to ensure that it is automatically updated by the cvs system.
     */
    public static final String VERSIONINFO =
        "$Id: Translator_01.java,v 1.30 2013/01/16 16:14:11 btatzmann Exp $";


    /**
     * Extension of the translated file. <BR/>
     * This extension is added to the output file which is generated by the
     * translator.
     */
    private String p_extension = null;

    /**
     *  Option to delete the file after a successfull translation. <BR/>
     */
    protected boolean p_isDeleteOriginal = false;

    /**
     *  Option to name the translation result like the name of the input name . <BR/>
     *  This will rename the original file in order to create the result with
     *  the nameof the input file. <BR/>
     */
    protected boolean p_isPreserveFileName = false;

    /**
     *  The transformer that will be created with the given filename. <BR/>
     */
    protected XSLTTransformer transformer = null;

    /**
     * Field name: extension. <BR/>
     */
    private static final String FIELD_EXTENSION = "extension";


    /**************************************************************************
     * Creates a Translator_01 Object. <BR/>
     */
    public Translator_01 ()
    {
        super ();
    } // Translator


    /**************************************************************************
     * Creates a Translator_01 Object. <BR/>
     *
     * @param oid   oid of the object
     * @param user  user that created the object
     *
     * @deprecated KR 20090723 This constructor should not be used.
     */
    public Translator_01 (OID oid, User user)
    {
        // call constructor of super class ObjectReference:
        super (oid, user);
    } // Translator


    /**************************************************************************
     * Setter method of the isDeleteOriginal option. <BR/>
     * Activate the option in case the original file should be deleted after
     * a successfull translation. <BR/>
     *
     * @param isDelete      the value of the option
     */
    public void setIsDeleteOriginal (boolean isDelete)
    {
        this.p_isDeleteOriginal = isDelete;
    } // setIsDeleteOriginal


    /**************************************************************************
     * Setter method of the isPreserveFileName option. <BR/>
     * Activate the option means that the translation result will have the
     * filename of the original file. <BR/>
     *
     * @param isPreserve      the value of the option
     */
    public void setIsPreserveFileName (boolean isPreserve)
    {
        this.p_isPreserveFileName = isPreserve;
    } // setIsPreserveFileName


    /**************************************************************************
     * This method makes the class specific initializations. <BR/>
     */
    public void initClassSpecifics ()
    {
        // set class specifics of super class:
        super.initClassSpecifics ();

        // set specific procedures:
        this.procCreate =     "p_Translator_01$create";
        this.procChange =     "p_Translator_01$change";
        this.procRetrieve =   "p_Translator_01$retrieve";
//        this.procDelete =     "p_Attachment_01$delete";
//        this.procDeleteRec =  "p_Attachment_01$delete";

        // set db table name:
        this.tableName = "ibs_Translator_01";

        // set number of parameters for procedure calls:
        this.specificRetrieveParameters += 1;
        this.specificChangeParameters += 1;

        // initialize specific properties:
    } // initClassSpecifics


    /**************************************************************************
     * Read the data used in the Object. <BR/>
     */
    public void getParameters ()
    {
        String str = null;              // a string parameter's value

        // call corresponding method of super class:
        super.getParameters ();

        // extension:
        if ((str = this.env.getStringParam (DIArguments.ARG_TRANSEXTENSION)) != null)
        {
            this.p_extension = str;
        } // if
    } // getParameters


    /**************************************************************************
     * Compute the full path and name of the xml source file. <BR/>
     *
     * @param   path        The path of the xml source file.
     * @param   fileName    The name of the xml source file.
     *
     * @return  the new file name or null of the name could not be created
     */
    public String computeXmlSourceFileName (String path, String fileName)
    {
        return fileName;
    } // computeXmlSourceFileName


    /**************************************************************************
     * Compute the full path and name of the source file. <BR/>
     *
     * @param   path        The path of the xml source file.
     * @param   fileName    The name of the xml source file.
     *
     * @return  the new file name or null of the name could not be created
     */
    public String computeSourceFileName (String path, String fileName)
    {
        String newFileName;

        // should the result file get the same filename as the input file?
        // if yes rename the input file in order to be able to create a
        // result file with the name of the input file
        if (this.p_isPreserveFileName)
        {
            // create a new name for the original file
            newFileName = FileHelpers.getUniqueFileName (path, "o_" + fileName);
            // rename the original file to "o_<filename>"
            if (FileHelpers.renameFile (path + fileName, path + newFileName))
            {
                return newFileName;
            } // if

            // could not rename
            return null;
        } // if (this.p_isPreserveFileName)

        // return the filename as is
        return fileName;
    } // computeSourceFileName


    /**************************************************************************
     * The translate method converts a data stream from its original format into
     * another format. <BR/>
     *
     * @param   sourcePath      Path of the file to convert.
     * @param   sourceFileName  Name of the file to convert.
     * @param   log             The log to write translation messages to.
     *
     * @return  The converted data stream.
     *
     * @throws  TranslationFailedException
     *          The translation could not be processed.
     */
    public String translate (String sourcePath, String sourceFileName,
                             Log_01 log) throws TranslationFailedException
    {
        String sourceFilePath = null;   // path and name of source file
        String xmlSourceFileName = null; // name of xml source file
        String xmlSourceFilePath = null; // path and name of xml source file
        String destinationFileName = null; // name of destination file
        String destinationFilePath = null; // path and name of destination file
        Source source = null;           // the xml input for translation
        OutputStream outStream = null;  // output stream for translated file
        long startTime;                 // the process start time
        XSLTTransformer transformer = null; // the transformer

        // log the translation start
        log.add (DIConstants.LOG_ENTRY, "Starting translation.");
        startTime = System.currentTimeMillis ();

        // ensure that the path is finished with a file separator
        String sourcePathLocal = FileHelpers.addEndingFileSeparator (sourcePath);
        String sourceFileNameLocal = sourceFileName;
        // compute the complete path + file name:

        // should the result get the same filename as the input file?
        if (this.p_isPreserveFileName)
        {
            // if yes the source file must be renamed
            // and the name of the destination file gets the name of the
            // source file
            destinationFileName = sourceFileName;
            sourceFileNameLocal = this.computeSourceFileName (
                sourcePathLocal, sourceFileName);
            // could the new source file name be created?
            if (sourceFileNameLocal == null)
            {
                throw new TranslationFailedException ( 
                    MultilingualTextProvider.getMessage (DIMessages.MSG_BUNDLE,
                        DIMessages.ML_MSG_COULD_NOT_RENAME_SOURCE_FILE, env));
            } // if
        } // if (this.p_isPreserveFileName)
        sourceFilePath = sourcePathLocal + sourceFileNameLocal;

        // compute the name and path of the generated intermediate xml files
        xmlSourceFileName = this.computeXmlSourceFileName (sourcePathLocal,
            sourceFileNameLocal);
        xmlSourceFilePath = sourcePathLocal + xmlSourceFileName;

        // should the result get the same filename as the input file?
        if (!this.p_isPreserveFileName)
        {
            // ensure that a correct extension is set else set the default
            if (this.p_extension == null || this.p_extension.trim ().length () == 0)
            {
                this.p_extension = "xml";
            } // if
            // create the name of the result file
            destinationFileName = FileHelpers.setNameExtension ("t_" +
                xmlSourceFileName, this.p_extension);
            // substitute critical characters in the pathname
            // the # turned out to cause errors
            destinationFileName = destinationFileName.replace ('#', '_');
            // ensure unique name
            destinationFileName = FileHelpers.getUniqueFileName (
                sourcePathLocal, destinationFileName);
        } // if (! this.p_isPreserveFileName)
        destinationFilePath = sourcePathLocal + destinationFileName;

        // generate the intermediate xml
        source = this.getSource (sourceFilePath, xmlSourceFilePath, log);
        if (source == null)           // translation not successful?
        {
            throw new TranslationFailedException ( 
                MultilingualTextProvider.getMessage (DIMessages.MSG_BUNDLE,
                    DIMessages.ML_MSG_TRANSLATIONFAILED, env));
        } // if translation not successful

        try
        {
            // open output stream:
            outStream = new FileOutputStream (destinationFilePath);

            // get the transformer:
            transformer = this.getTransformer ();
            // translate the file:
            transformer
                .translateFile (source, new StreamResult (outStream));

            // check if the original source file should be deleted
            if (this.p_isDeleteOriginal)
            {
                // delete the source file
                if (!FileHelpers.deleteFile (sourceFilePath))
                {
                    log.add (DIConstants.LOG_ERROR, 
                        MultilingualTextProvider.getMessage (DIMessages.MSG_BUNDLE,
                            DIMessages.ML_MSG_COULD_NOT_DELETE_FILE,
                            new String[] {sourceFilePath}, env));
                } // if
            } // if (this.isDeleteOriginal)
        } // try
        catch (XSLTTransformationException e)
        {
            // throw an exception:
            throw new TranslationFailedException (
                MultilingualTextProvider.getMessage (DIMessages.MSG_BUNDLE,
                    DIMessages.ML_MSG_TRANSLATIONFAILED, env) 
                + " (" + e.getMessage () + ")", e);
        } // catch
        catch (FileNotFoundException e)
        {
            // throw an exception:
            throw new TranslationFailedException (
                MultilingualTextProvider.getMessage (DIMessages.MSG_BUNDLE,
                    DIMessages.ML_MSG_TRANSLATIONFAILED, env) 
                + " (" + e.getMessage () + ")", e);
        } // catch
        finally
        {
            try
            {
                if (outStream != null)
                {
                    // close output stream:
                    outStream.close ();
                } // if
/* the xml input stream should be closed, too:
                if (xmlInput != null)
                {
                    xmlInput.
                } // if
*/
            } // try
            catch (IOException e)
            {
                // throw an exception:
                throw new TranslationFailedException ( 
                    MultilingualTextProvider.getMessage (DIMessages.MSG_BUNDLE,
                        DIMessages.ML_MSG_TRANSLATIONFAILED, env) 
                        + " (could not close outfile: " + e.getMessage () + ")", e);
            } // catch

            // delete the temporary files:
            if (!sourceFilePath.equals (xmlSourceFilePath) &&
                !FileHelpers.deleteFile (xmlSourceFilePath))
                                        // file not deleted?
            {
                log.add (DIConstants.LOG_ENTRY,
                         "Could not delete temporary xml file.");
            } // if file not deleted
        } // finally

        // log the translation completion:
        log.add (DIConstants.LOG_ENTRY,
                 "Translation finished, running time: " +
                 (System.currentTimeMillis () - startTime) + " ms.");

        // return the name of the translated file:
        return destinationFileName;
    } // translate


    /**************************************************************************
     * Translate the original file into an xml structure which shall be
     * translated into the new xml structure. <BR/>
     * The original file may be not xml conform. So we need an algorithm which
     * converts the original file into standard xml code. <BR/>
     * The generated xml file is used as input for the xslt translation process.
     * Note that this method has to be overwritten in case the input source
     * file is not xml. <BR/>
     *
     * @param   sourceFile      The path and name of the source file.
     * @param   xmlFile         The path and name which shall be used for the
     *                          xml file.
     * @param   log             The log to write translation messages to.
     *
     * @return  The intermediate xml document or <CODE>null</CODE> if it could
     *          not be created.
     */
    protected Source getSource (String sourceFile, String xmlFile, Log_01 log)
    {
        // the original file is already xml, return it:
        // return the computed file:
        return new StreamSource (new File (sourceFile));
/*
        } // try
        catch (FileNotFoundException e)
        {
            IOHelpers.showMessage (e, this.app, this.sess, this.env, true);
            return (null);
        } // catch
*/
    } // getSource


    /**************************************************************************
     * Get the transformer that will be created with the given XSLT file. <BR/>
     * Note that the translator is buffering the transformer at first
     * initialization in order to improve performance. <BR/>
     *
     * @return  the transformer
     *
     * @throws  XSLTTransformationException
     *          An exception occurred durint the XSLT transformation.
     * @throws  TranslationFailedException
     *          The translation failed.
     */
    public XSLTTransformer getTransformer ()
        throws XSLTTransformationException, TranslationFailedException
    {
        String xsltFilePath = null;     // path and name of xslt file

        // check if the transformer has already been initialized:
        if (this.transformer != null)
        {
            return this.transformer;
        } // if (this.transformer != null)

        // yet no translator set
        // has a filename for the translator been set
        if ((xsltFilePath = this.getAbsFilePath ()) == null) // no XSLT file set?
        {
            // throw the corresponding exception:
            throw new TranslationFailedException ( 
                MultilingualTextProvider.getMessage (DIMessages.MSG_BUNDLE,
                    DIMessages.ML_MSG_NO_TRANSLATOR_SET, env));
        } // else no XSLT file set

        // xslt file set
        // create the transformer and set it in the buffer
        this.transformer = new XSLTTransformer (xsltFilePath);
        return this.transformer;
    } // getTransformer


    /**************************************************************************
     * Displays the settings of the translator. <BR/>
     *
     * @param   table       Table where the settings shall be added.
     */
    public void showSettings (TableElement table)
    {
        // display the specific settings:
        this.showProperty (table, DIArguments.ARG_TRANSLATOR,
            MultilingualTextProvider.getText (DITokens.TOK_BUNDLE, 
                DITokens.ML_TRANSLATOR, env),
            Datatypes.DT_NAME, this.name);
        this.showProperty (table, DIArguments.ARG_TRANSEXTENSION,
            MultilingualTextProvider.getText (DITokens.TOK_BUNDLE, 
                DITokens.ML_TRANSEXTENSION, env), Datatypes.DT_TEXT,
            this.p_extension);
    } // showSettings


    /**************************************************************************
     * Add the settings of the translator to a log. <BR/>
     *
     * @param   log     The log to add the settings to.
     */
    public void addSettingsToLog (Log_01 log)
    {
        // add translator specific settings:
        log.add (DIConstants.LOG_ENTRY,    
            MultilingualTextProvider.getText (DITokens.TOK_BUNDLE, 
                DITokens.ML_TRANSLATOR, env) + ": " +
            this.name, false);
        log.add (DIConstants.LOG_ENTRY, 
            MultilingualTextProvider.getText (DITokens.TOK_BUNDLE, 
                DITokens.ML_TRANSEXTENSION, env) + ": " +
            this.p_extension, false);
    } // addSettingsToLog


    /**************************************************************************
     * Represent the properties of an object to the user. <BR/>
     *
     * @param   table       Table where the properties should be added.
     */
    protected void showProperties (TableElement table)
    {
        // display common properties:
        super.showProperties (table);

        // display the specific properties:
        this.showProperty (table, DIArguments.ARG_TRANSEXTENSION,
            MultilingualTextProvider.getText (DITokens.TOK_BUNDLE, 
                DITokens.ML_TRANSEXTENSION, env), Datatypes.DT_TEXT,
            this.p_extension);
    } //  showProperties


    /**************************************************************************
     * Represent the properties of an object to the user within a form. <BR/>
     *
     * @param   table       Table where the properties shall be added.
     */
    protected void showFormProperties (TableElement table)
    {
        // display common properties:
        super.showFormProperties (table);

        // display the specific properties:
        this.showFormProperty (table, DIArguments.ARG_TRANSEXTENSION,
            MultilingualTextProvider.getText (DITokens.TOK_BUNDLE, 
                DITokens.ML_TRANSEXTENSION, env), Datatypes.DT_TEXT,
            this.p_extension);
    } // showFormProperties


    /**************************************************************************
     * Read the object data from a DataElement. <BR/>
     *
     * @param   dataElement The dataElement to read the data from.
     *
     * @see ibs.bo.BusinessObject#readImportData
     */
    public void readImportData (DataElement dataElement)
    {
        // get common values:
        super.readImportData (dataElement);

        // get the type specific values:
        if (dataElement.exists (Translator_01.FIELD_EXTENSION))
        {
            this.p_extension = dataElement
                .getImportStringValue (Translator_01.FIELD_EXTENSION);
        } // if
    } // readImportData


    /**************************************************************************
     * Write the object data into a DataElement. <BR/>
     *
     * @param   dataElement The dataElement to write the data to.
     *
     * @see ibs.bo.BusinessObject#writeExportData
     */
    public void writeExportData (DataElement dataElement)
    {
        // set common values:
        super.writeExportData (dataElement);

        // set the connector specific values:
        dataElement.setExportValue (Translator_01.FIELD_EXTENSION,
            this.p_extension);
    } // writeExportData


    ///////////////////////////////////////////////////////////////////////////
    // database functions
    ///////////////////////////////////////////////////////////////////////////

    /**************************************************************************
     * Set the data for the additional (type specific) parameters for
     * performChangeData. <BR/>
     * This method must be overwritten by all subclasses that have to pass
     * type specific data to the change data stored procedure.
     *
     * @param sp        The stored procedure to add the change parameters to.
     */
    @Override
    protected void setSpecificChangeParameters (StoredProcedure sp)
    {
        // initialize params index
        super.setSpecificChangeParameters (sp);

        // set the specific parameters:
        // extension:
        sp.addInParameter (ParameterConstants.TYPE_STRING,
                        this.p_extension);
    } // setSpecificChangeParameters


    /**************************************************************************
     * Set the data for the additional (type specific) parameters for
     * performRetrieveData. <BR/>
     * This method must be overwritten by all subclasses that have to pass
     * type specific data to the retrieve data stored procedure.
     *
     * @param sp        The stored procedure the specific retrieve parameters
     *                  should be added to.
     * @param params    Array of parameters the specific retrieve parameters
     *                  have to be added to for beeing able to retrieve the
     *                  results within getSpecificRetrieveParameters.
     * @param lastIndex The index to the last element used in params thus far.
     *
     * @return  The index of the last element used in params.
     */
    @Override
    protected int setSpecificRetrieveParameters (StoredProcedure sp, Parameter[] params,
                                                 int lastIndex)
    {
        // initialize params index
        int i = super.setSpecificRetrieveParameters (sp, params, lastIndex);

        // set the specific parameters:
        // extension:
        params[++i] = sp.addOutParameter (ParameterConstants.TYPE_STRING);

        return i;                       // return the current index
    } // setSpecificRetrieveParameters


    /**************************************************************************
     * Get the data for the additional (type specific) parameters for
     * performRetrieveData. <BR/>
     * This method must be overwritten by all subclasses that have to get
     * type specific data from the retrieve data stored procedure.
     *
     * @param   params      The array of parameters from the retrieve data stored
     *                      procedure.
     * @param   lastIndex   The index to the last element used in params thus far.
     */
    protected void getSpecificRetrieveParameters (Parameter[] params,
                                                  int lastIndex)
    {
        // read the parameter in the super class which
        // will be attachment_01
        super.getSpecificRetrieveParameters (params, lastIndex);

        // initialize params index
        // attachment_01 reads 7 parameters in its getSpecificRetrieveParameters
        // method therefore we have to add 7 to the params index
        int i = lastIndex + 7;

        // get the specific parameters:
        this.p_extension = params[++i].getValueString ();
    } // getSpecificRetrieveParameters


    /**************************************************************************
     * Sets the buttons that can be displayed when the user is in an
     * object's info view. <BR/>
     * This method can be overwritten in subclasses to redefine the set of
     * buttons that can be displayed. <BR/>
     *
     * @return  An array with button ids that can potentially be displayed.
     */
    protected int[] setInfoButtons ()
    {
        // define buttons to be displayed:
        int [] buttons =
        {
            Buttons.BTN_EDIT,
            Buttons.BTN_DELETE,
            Buttons.BTN_CUT,
            Buttons.BTN_COPY,
            Buttons.BTN_DISTRIBUTE,
        }; // buttons

        // return button array
        return buttons;
    } // setInfoButtons

} // class Translator_01
